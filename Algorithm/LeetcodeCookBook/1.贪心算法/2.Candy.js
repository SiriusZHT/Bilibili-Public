// 135. Candy (Hard)
// 题目描述
// 一群孩子站成一排，每一个孩子有自己的评分。
// 现在需要给这些孩子发糖果，规则是如果一个孩子的评分比自己身旁的一个孩子要高，那么这个孩子就必须得到比身旁孩子更多的糖果；
// 所有孩子至少要有一个糖果。求解最少需要多少个糖果。

// 输入输出样例输入是一个数组，表示孩子的评分。输出是最少糖果的数量。
// Input: [1,0,2] Output: 5 在这个样例中，最少的糖果分法是 [2,1,2]。

// 思路：
// 把所有孩子的糖果数 初始化为 1
// 先从左往右遍历一遍 如果右边孩子的评分比左边的高 右边孩子的糖果数更新为左边的糖果树+1
// 再从右往左遍历一遍 如果左边孩子的评分比右边的高，且左边孩子当前的糖果树不大于右边的孩子的糖果数
// 左边孩子的糖果数更新为右边孩子的糖果数+1
// 贪心策略为：每次遍历 只保证一个方向上的满足条件

function candy(ratings=[]){
    let size = ratings.length;
    if(size < 2){
        return size;
    }
    // 因为每个人都要分糖果 所以初始化为1
    let num = new Array(size).fill(1);
    // 从左到右
    for(let i = 1; i < size; i++){
        // 如果右边的rate大于左边的 右边的糖果就比左边多一个
        ratings[i] > ratings[i - 1] && (num[i] = num[i - 1] + 1);
    }
    // 从右到左
    for(let i = size - 1; i > 0; i--){
        // 如果左边的rate大于右边的 并且左边的糖果数量比右边的小（因为之前的循环可能会让左边的比右边的大） 左边的糖果就比右边多一个
        ratings[i] < ratings[i - 1] && (num[i - 1] = Math.max(num[i - 1], num[i] + 1));
    }
    // 最后num数组累加，reduce两个参数 1.累加器函数 2.初始值
    return num.reduce((total, item) => total + item, 0);
}

console.log(candy([1, 0, 2]))
// 435. Non-overlapping Intervals (Medium) 
// 题目描述
// 给定多个区间，计算让这些区间互不重叠所需要移除区间的最少个数。 起止相连不算重叠

// 输入输出样例
// 输入是一个数组，数组由多个长度固定为 2 的数组组成，表示区间的开始和结尾。输出一个整数，表示需要移除的区间数量。
// Input: [[1,2], [2,4], [1,3]] Output: 1 在这个样例中，我们可以移除区间 [1,3]，使得剩余的区间 [[1,2], [2,4]] 互不重叠。

// 思路
// 选择保留区间时，区间的结尾十分重要，选择的区间结尾越小，预留给其他区间的空间就越大，就越能保留更多的区间
// 贪心策略：优先保留(可以看作 数组遍历的进位) 结尾小 且 不相交 的区间

// 先把区间按照结尾的大小进行赠序排序，每次选择结尾最小 且 和前一个选择的区间不重叠的区间
// 因为排序了，所以左边元素的左边界 一定小于 (左边元素的右边界 一定小于 右边元素的右边界)

// 所以排序后的相交的定义：
// 排序后的左边元素的右边界 大于 右边的左边界 

// 例如 本例中 排序后的数组为 [[1,2], [1,3], [2,4]]。按照我们的贪心策略，首先初始化为区间[1,2]；
// 由于 [1,3] 与 [1,2] 相交，我们跳过该区间； 
// 由于 [2,4] 与 [1,2] 不相交，我们将其保留。
// 因此最终保留的区间为 [[1,2], [2,4]]。

function eraseOverlapIntervals(intervals=[[]]) {
    if(!intervals.length){
        return 0;
    }
    let n = intervals.length;
    // 按照结尾的大小 赠序排序
    intervals.sort((a, b) => a[1] - b[1]);
    let total = 0;
    // 前面元素的结尾
    let prev = intervals[0][1];
    for(let i = 1; i < n; i++){
        // 左边的右边界 大于 右边的左边界
        if(intervals[i][0] < prev){
            ++total;
        } else {
            prev = intervals[i][1];
        }
    }
    return total;
}

console.log(eraseOverlapIntervals([[1,2], [1,3], [2,4]]));